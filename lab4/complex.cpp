#include <iostream>
using namespace std;


class Complex 
{
   private:
      double real;
      double imag;
   public:
      // NB:  I am defining a lot of these functions in the class
      // specification, since they are so short.  This is still
      // readable for short functions, but bad style for long ones.
      // It also can help make the object code generated by the
      // compiler more efficient by making it easier for the 
      // compiler to "inline" (directly execute rather than call
      // a function, which has some overhead) these small functions.

      // Constructors.  
      Complex(double r, double i) { real = r; imag = i;}
      Complex(double r) { real = r; imag = 0.; }
      Complex() { real = 0.; imag = 0.; };

      // Accessors
      double getReal () const  {return (real); }
      double getImag () const { return (imag); }

      // Overloaded operators
      friend Complex operator +(Complex x, Complex y);
      bool operator == (Complex rhs) const;
      Complex operator - () const;
};


// Binary addition operator.
// Define as friend so we can directly access private 
// variables rather than using accessors, to make coding shorter 
// and program a bit faster.  Using friend instead of member function 
// to make automatic type conversion of
// inputs via the constructors I've defined work for both inputs.

Complex operator +(Complex x, Complex y) // Not a member function
{
   return Complex (x.real + y.real, 
                   x.imag + y.imag);
}


// Equality test operator.  No default provided by C++, so I must 
// make one if I want to use it.  Using member function, but could
// use friend or regular function (with accessors) if I wanted.
bool Complex::operator == (Complex rhs) const
{
   if (real == rhs.real && imag == rhs.imag) 
      return (true);
   else
      return (false);
}


// Unary negation operator.  Only argument is the calling object.
Complex Complex::operator - () const
{
   return (Complex (-real, -imag));
}


// Output insertion operator.  Can't be member function since
// stream must be the left operand (stream would have to be calling 
// object, which means we'd have to make it a member of the iostream 
// class, not the Complex class).
// Could make friend (didn't), or just use accessor functions (did).
ostream & operator << (ostream &out, Complex num) 
{
   out << num.getReal();

   if (num.getImag() >= 0) 
      out << "+";
      // if < 0, get a - printed as part of the number.

   out << num.getImag() << "i\n";
   return (out);
}


int main () 
{
   Complex a(1., 2.), b (1., -3.), c;
   double d = 1.;

   // Uses overloaded "+" operator
   c = a + b;
 
   // Uses overloaded stream output operator.
   cout << "a: " << a << "b: " << b;
   cout << "c = a + b: " << c;
   //cout << c.getReal() << " + " << c.getImag() << "i\n"; 

   // No operator matches (double) + (complex).
   // Compiler looks for constructors that can convert types.
   // Finds a constructor for double -> Complex.
   // Invokes constructor to create a temporary Complex, which
   // it passes to the (complex) + (complex) operator.
   c = 1. + c;   
   cout << "c = 1. + c: " << c;

   c = -c;
   cout << "c = -c: " << c;
   
   // Overloaded == operator. C++ provides no default 
   // so we must define it if we want to use it.
   if (a == b) 
      cout << "a equals b!\n";
   else
      cout << "a not equal to b!\n";

   // No need to overload =, as C++ provides a default one that 
   // does what we need (shallow copy of all data members).
   a = b;
   cout << "a = b, now a: " << a;

   if (a == b) 
      cout << "a equals b!\n";
   else
      cout << "a not equal to b!\n";

   // We haven't defined an assignment operator for double to Complex.  But C++ 
   // has defined a default Complex to Complex assignment operator, and we have a 
   // constructor to turn a double into a Complex.  Hence C++ uses the constructor 
   // to make a temporary "Complex (1.)" which it passes into the assignment operator.
   a = 1.;  
   cout << "a = 1., now a: " << a;

   if (a == 1.) 
      cout << "a equals 1.\n";

   return (0);
}

